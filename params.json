{"name":"Nanostore","body":"# Welcome To NanoStore\r\n\r\n**What is NanoStore?**\r\n\r\nNanoStore is an open source, lightweight schema-less local key-value document store written in Objective-C for Mac OS X and iOS.\r\n\r\nRelational databases tend to have a rich understanding of the structure of your data, but requires some planing beforehand and some level of maintenance as well. NanoStore provides the flexibility that comes with key-value document stores, but still understands something about your data. Because the data is key-value based, it can be accessed quickly and can grow as much as needed... all without ever worrying about the schema.\r\n\r\n**Main advantages**\r\n\r\n* No SQL knowledge required\r\n* Schema-less\r\n* Key-value based storage\r\n* Store your own custom objects\r\n* Bags, a free-form relational system\r\n* Fast, direct object manipulation\r\n* Dynamic queries\r\n* Full index support, inner-objects, embedded arrays and dictionaries\r\n* Convenience methods to access, manipulate and maintain SQLite databases\r\n* Full SQLite access available\r\n* Mac OS X Lion 10.7 and iOS 5 ready\r\n* iOS library runs on the device and simulator\r\n* ARC compliant\r\n\r\n# Installation\r\n\r\nBuilding NanoStore is very easy. Just follow these steps:\r\n\r\n    1) Download NanoStore\r\n    2) Open the NanoStore.xcodeproj file\r\n    3) Select Universal > My Mac 64-bit or 32-bit from the Scheme popup\r\n    4) Build (Command-B)\r\n\r\nNow you should have a new ***Distribution*** directory within the NanoStore project directory which contains the Universal static library (armv6/armv7/i386) as well as the header files. To add it in your project, do the following:\r\n\r\n    1) Drag the Distribution directory to the Project Navigator panel\r\n    2) Include #import \"NanoStore.h\" in your code\r\n\r\nExample:\r\n\r\n    #import \"NanoStore.h\"\r\n    \r\n    @implementation MyDemoAppDelegate\r\n    \r\n    - (BOOL)application:(UIApplication *)application\r\n            didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\r\n    {\r\n\t    // Override point for customization after application launch.\r\n        // Instantiate a NanoStore and open it\r\n        \r\n        NSFNanoStore *nanoStore = [NSFNanoStore\r\n\tcreateAndOpenStoreWithType:NSFMemoryStoreType path:nil error:nil];\r\n        ...\r\n    }\r\n\r\n### Note\r\n    If you want to add a dependency between your project and NanoStore so that it gets\r\n    automatically rebuilt when you update NanoStore, do the following (we'll assume\r\n    your app is called \"MyDemoApp\"):\r\n\r\n\t1) Select the MyDemoApp project in the Project Navigator\r\n\t2) Select the MyDemoApp target\r\n\t3) Expand the Target Dependencies box\r\n\t4) Click \"+\" and add NanoStore\r\n\t\t\t\t\t\r\n# How does NanoStore work?\r\n\r\nThe basic unit of data in NanoStore is called NanoObject. A NanoObject is any object which conforms to the `NSFNanoObjectProtocol` protocol.\r\n\r\nAt its core, a NanoObject is nothing more than a wrapper around two properties:\r\n\r\n* A dictionary which contains the metadata (provided by the developer)\r\n* A key (UUID) that identifies the object (provided by NanoStore)\r\n\r\nThe dictionary must be serializable, which means that only the following data types are allowed:\r\n\r\n* NSArray\r\n* NSDictionary\r\n* NSString\r\n* NSData (*)\r\n* NSDate\r\n* NSNumber\r\n\r\n### Note\r\n    (*) The data type NSData is allowed, but it will be excluded from the indexing\r\n    process.\r\n\r\nTo save and retrieve objects from the document store, NanoStore moves the data around by encapsulating it in NanoObjects. In order to store the objects in NanoStore the developer has three options:\r\n\r\n* Use the `NSFNanoObject` class directly\r\n* Expand your custom classes by inheriting from `NSFNanoObject`\r\n* Expand your custom classes by implementing the `NSFNanoObjectProtocol` protocol\r\n\r\nRegardless of the route you decide to take, NanoStore will be able to store and retrieve objects from the document store seamlessly. The beauty of this system is that NanoStore returns the object as it was stored, that is, instantiating an object of the class that was originally stored.\r\n\r\n### Note\r\n    If the document store is opened by another application that doesn't implement the\r\n    object that was stored, NanoStore will instantiate a NSFNanoObject instead, thus\r\n    allowing the app to retrieve the data seamlessly. If the object is then updated by\r\n    this application, the original class name will be honored.\r\n\r\n### Example\r\n\t1. App A stores an object of class Car.\r\n\t2. App B retrieves the object, but since it doesn't know anything about the\r\n           class Car, NanoStore returns a NSFNanoObject.\r\n\t3. App B updates the object, with additional information. NanoStore saves it\r\n           as a Car, not as a NSFNanoObject.\r\n\t4. App A retrieves the updated object as a Car object, in exactly the same\r\n           format as it was originally stored.\r\n\r\n# Types of Document Stores\r\n\r\nThere are three types of document stores available in NanoStore: in-memory, temporary and file-based. These document stores are defined by the `NSFNanoStoreType` type:\r\n\r\n`NSFMemoryStoreType`\r\n\r\n    Create the transient backing store in RAM. Its contents are lost when the process\r\n    exits. Fastest, uses more RAM (*).\r\n\r\n`NSFTemporaryStoreType`\r\n\r\n    Create a transient temporary backing store on disk. Its contents are lost when the\r\n    process exits. Slower, uses less RAM than NSFMemoryStoreType.\r\n\t\r\n`NSFPersistentStoreType`\r\n\r\n    Create a persistent backing store on disk. Slower, uses less RAM than\r\n    NSFMemoryStoreType (*).\r\n\r\n### Note\r\n    Until the limit set by NSFNanoEngine's - (NSUInteger)cacheSize has been reached,\r\n    memory usage would be the same for in-memory and on-disk stores. When the size of\r\n    the store grows beyond - (NSUInteger)cacheSize in-memory stores start to consume\r\n    more memory than on-disk ones, because it has nowhere to push pages out of the\r\n    cache.\r\n\r\n    Typically, most developers may want to create and open the document store. To do\r\n    that, use the following method:\r\n\r\n    + (NSFNanoStore *)createAndOpenStoreWithType:(NSFNanoStoreType)aType\r\n\t                                    path:(NSString *)aPath\r\n\t                                   error:(out NSError **)outError\r\n\r\n### Example\r\n    // Instantiate an in-memory document store and open it.\r\n    // The path parameter is unused.\r\n    NSFNanoStore *nanoStore = [NSFNanoStore\r\n\tcreateAndOpenStoreWithType:NSFMemoryStoreType path:nil error:nil];\r\n \r\n    // Instantiate a temporary document store and open it.\r\n    // The path parameter is unused.\r\n    NSFNanoStore *nanoStore = [NSFNanoStore\r\n\tcreateAndOpenStoreWithType:NSFTemporaryStoreType path:nil error:nil];\r\n \r\n    // Instantiate a file-based document store and open it.\r\n    // The path parameter must be specified.\r\n    NSString *thePath = @\"~/Desktop/myDatabase.database\";\r\n    NSFNanoStore *nanoStore = [NSFNanoStore\r\n\tcreateAndOpenStoreWithType:NSFPersistentStoreType path:thePath error:nil];\r\n\r\n### Note\r\n    In the case of file-based document stores, the file gets created automatically if\r\n    it doesn't exist and then opened. If it already exists, it gets opened and made\r\n    available for use right away.\r\n\r\n    There are instances where you may want to fine-tune the engine. Tuning the engine\r\n    has to be performed before the document store is opened. Another method is\r\n    available in NSFNanoStore for this purpose:\r\n\t\r\n    + (NSFNanoStore *)createStoreWithType:(NSFNanoStoreType)theType\r\n                                     path:(NSString *)thePath.\r\n\r\n### Example\r\n    // Instantiate a file-based document store but don't open it right away. The path\r\n    // parameter must be specified.\r\n    NSString *thePath = @\"~/Desktop/myDatabase.database\";\r\n    NSFNanoStore *nanoStore = [NSFNanoStore\r\n\tcreateStoreWithType:NSFPersistentStoreType path:thePath error:nil];\r\n    \r\n    // Obtain the engine\r\n    NSFNanoEngine *nanoStoreEngine = [nanoStore nanoStoreEngine];\r\n \r\n    // Set the synchronous mode setting\r\n    [nanoStoreEngine setSynchronousMode:SynchronousModeOff];\r\n    [nanoStoreEngine setEncodingType:NSFEncodingUTF16];\r\n    \r\n    // Open the document store\r\n    [nanoStore openWithError:nil];\r\n\r\n### Note\r\n    Check the section Performance Tips below for important information about how to get\r\n    the most out of NanoStore.\r\n\r\n# Working with a NanoObject\r\n\r\nThere are three basic operations that NanoStore can perform with a NanoObject:\r\n\r\n* Add it to the document store\r\n* Update an existing object in the document store\r\n* Remove it from the document store\r\n\r\nTo add an object, instantiate a `NSFNanoObject`, populate it and add it to the document store.\r\n\r\n### Example\r\n    // Instantiate a NanoStore and open it\r\n    NSFNanoStore *nanoStore = [NSFNanoStore\r\n        createAndOpenStoreWithType:NSFMemoryStoreType path:nil error:nil];\r\n    \r\n    // Generate an empty NanoObject\r\n    NSFNanoObject *object = [NSFNanoObject nanoObject];\r\n    \r\n    // Add some data\r\n    [object setObject:@\"Doe\" forKey:@\"kLastName\"];\r\n    [object setObject:@\"John\" forKey:@\"kFirstName\"];\r\n    [object setObject:[NSArray arrayWithObjects:@\"jdoe@foo.com\", @\"jdoe@bar.com\", nil]\r\n\t                                     forKey:@\"kEmails\"];\r\n    \r\n    // Add it to the document store\r\n    [nanoStore addObject:object error:nil];\r\n    \r\n    // Close the document store\r\n    [nanoStore closeWithError:nil];\r\n\r\nAlternatively, you can instantiate a NanoObject providing a dictionary via:\r\n\r\n    + (NSFNanoObject*)nanoObjectWithDictionary:(NSDictionary *)theDictionary\r\n\r\nNanoStore will assign a UUID automatically when the NanoObject is instantiated. This means that requesting the key from the NanoObject will return a valid UUID. The same holds true for objects that inherit from `NSFNanoObject`. However, classes that implement the `NSFNanoObjectProtocol` protocol should make sure they return a valid key via:\r\n\r\n    - (NSString *)nanoObjectKey\r\n\r\n### Warning\r\n    If an attempt is made to add or remove an object without a valid key, an exception\r\n    of type NSFNanoObjectBehaviorException will be raised. To update an object, simply\r\n    modify the object and add it to the document store. NanoStore will replace the\r\n    existing object with the one being added.\r\n\r\n### Example\r\n    // Instantiate and open a NanoStore\r\n    NSFNanoStore *nanoStore = [NSFNanoStore\r\n        createAndOpenStoreWithType:NSFMemoryStoreType path:nil error:nil];\r\n    \r\n    // Assuming the dictionary exists, instantiate a NanoObject\r\n    NSDictionary *info = ...;\r\n    NSFNanoObject *object = [NSFNanoObject nanoObjectWithDictionary:info];\r\n    \r\n    // Add the NanoObject to the document store\r\n    [nanoStore addObject:object error:nil];\r\n    \r\n    // Update the NanoObject with new data\r\n    [object setObject:@\"foo\" forKey:@\"SomeKey\"];\r\n    \r\n    // Update the NanoObject in the document store\r\n    [nanoStore addObject:object error:nil];\r\n\r\nTo remove an object, there are several options available. The most common methods are found in NSFNanoStore:\r\n\r\n\t- (BOOL)removeObject:(id <NSFNanoObjectProtocol>)theObject\r\n\t               error:(out NSError **)outError\r\n\r\n\t- (BOOL)removeObjectsWithKeysInArray:(NSArray *)theKeys\r\n\t                               error:(out NSError **)outError\r\n\r\n\t- (BOOL)removeObjectsInArray:(NSArray *)theObjects\r\n\t                       error:(out NSError **)outError\r\n\r\n### Example\r\n    // Instantiate and open a NanoStore\r\n    NSFNanoStore *nanoStore = [NSFNanoStore\r\n        createAndOpenStoreWithType:NSFMemoryStoreType path:nil error:nil];\r\n    \r\n    // Assuming the dictionary exists, instantiate a NanoObject\r\n    NSDictionary *info = ...;\r\n    NSFNanoObject *object = [NSFNanoObject nanoObjectWithDictionary:info];\r\n    \r\n    // Add the NanoObject to the document store\r\n    [nanoStore addObject:object error:nil];\r\n    \r\n    // Remove the object\r\n    [nanoStore removeObject:object error:nil];\r\n    \r\n    // ... or you could pass the key instead\r\n    [nanoStore\r\n        removeObjectsWithKeysInArray:[NSArray arrayWithObject:[object nanoObjectKey]]\r\n        error:nil];\r\n\r\n# It's not a flat World\r\n\r\nMost database solutions force the developer to think in a two-dimensional space (rows and columns), forcing the developer to plan the schema ahead of time. This situation is not ideal because in most cases schema refinements could be required, oftentimes impacting the code as well.\r\n\r\nNanoStore goes beyond that allowing the developer to store objects in their natural form. These objects must conform to the `NSFNanoObjectProtocol` protocol, providing NanoStore with the NSDictionary that will be stored. By using a dictionary data can be inspected very quickly, and it also allows the structure to be defined in a hierarchical fashion as well, due to the fact that it includes support for nested collections (of type NSDictionary and NSArray.) Each inner-object is indexed automatically, thus allowing to quickly find objects which contain a specific key and/or value.\r\n\r\nBy default, NanoStore allows objects to be stored without any sense of relationship to other objects. This simple format, while powerful, is limited because the developer has to keep track of the relationships among objects. Some applications may need to relate objects, some of them perhaps of different nature or class type. This is exactly what NanoBag (represented by the `NSFNanoBag` class) does: it allows any object conforming to the `NSFNanoObjectProtocol` protocol to be added to the bag. By saving the bag with one single call, the new and/or modified NanoObjects are taken care of seamlessly.\r\n\r\nThe `NSFNanoBag` API is rich, allowing the developer to add, remove, reload and undo its changes, deflate it (thus saving memory) and inflate it whenever it's required. In addition, it provides methods to obtain all bags, specific bags matching some keys, and bags containing a specific object (see `NSFNanoStore` for more information).\r\n\r\n# Where are my objects?\r\n\r\nWhile `NSFNanoStore` provides some convenience methods to obtain standard objects such as bags, the bulk of the search mechanism is handled by `NSFNanoSearch`. The steps involved to perform a search are quite simple:\r\n\r\n    1. Instantiate a search object\r\n    2. Configure the search via its accessors\r\n    3. Obtain the results specifying whether objects or keys should be returned (*)\r\n\r\n### Note\r\n    (*) If introspecting the data is needed, request objects. You should request keys\r\n    if you need to feed the result to another method, such as the following method in\r\n    NSFNanoStore:\r\n\t\r\n\t-(BOOL)removeObjectsWithKeysInArray:(NSArray *)theKeys\r\n\t                              error:(out NSError **)outError\r\n\r\n### Example: finding all objects with the attribute 'LastName' and value 'Doe'\r\n\r\n    NSFNanoSearch *search = [NSFNanoSearch searchWithStore:nanoStore];\r\n    \r\n    search.attribute = @\"LastName\";\r\n    search.match = NSFEqualTo;\r\n    search.value = @\"Doe\";\r\n    \r\n    // Returns a dictionary mapping the UUID to the NanoObject.\r\n    NSDictionary *searchResults = [search\r\n        searchObjectsWithReturnType:NSFReturnObjects error:nil];\r\n\r\n### Example: removing all objects with the attribute 'LastName' and value 'Doe'\r\n\r\n    NSFNanoSearch *search = [NSFNanoSearch searchWithStore:nanoStore];\r\n    \r\n    search.attribute = @\"LastName\";\r\n    search.match = NSFEqualTo;\r\n    search.value = @\"Doe\";\r\n    \r\n    // Returns an array of matching UUIDs\r\n    NSArray *matchingKeys = [search searchObjectsWithReturnType:NSFReturnKeys\r\n                                                          error:nil];\r\n    \r\n    // Remove the NanoObjects matching the selected UUIDs\r\n    NSError *outError = nil;\r\n    if (YES == [nanoStore removeObjectsWithKeysInArray:matchingKeys\r\n                                                 error:&outError]) {\r\n       NSLog(@\"The matching objects have been removed.\");\r\n    } else {\r\n       NSLog(@\"An error has occurred while removing the matching objects.\r\n               Reason: %@\", [outError localizedDescription]);\r\n    }\r\n\r\n### Example: calculating the average salary of all objects with the attribute 'LastName' and value 'Doe'\r\n\r\nAnother cool feature is the possibility to invoke aggregated functions (count, avg, min, max and total) on the search results. Using the search snippet above, calculating the average salary of all people with last name equal to 'Doe' is very easy.\r\n\r\n    NSFNanoSearch *search = [NSFNanoSearch searchWithStore:nanoStore];\r\n    \r\n    search.attribute = @\"LastName\";\r\n    search.match = NSFEqualTo;\r\n    search.value = @\"Doe\";\r\n    \r\n    float averageSalary = [[search aggregateOperation:NSFAverage\r\n                                          onAttribute:@\"Salary\"]floatValue];\r\n\r\n# Sorting\r\n\r\nCombining search and sort is an extremely easy operation. There are two simple parts:\r\n\r\n    1. Preparing your classes for sorting\r\n    2. Setup a search operation and set its sort descriptors\r\n\r\n### Preparing your classes for sorting\r\n\r\nSince NanoStore relies on KVC to perform the sorts, a hint of the location where the data lives within the object is required. Since KVC uses a key path to reach the element being sorted, we need a way to \"point\" to it. Most custom classes will return *self*, as is the case for NSFNanoBag:\r\n\r\n    - (id)rootObject\r\n    {\r\n        return self;\r\n    }\r\n\r\n*Self* in this case represents the top level, the location where the variables *name*, *key* and *hasUnsavedChanges* are located:\r\n\r\n    @interface NSFNanoBag : NSObject <NSFNanoObjectProtocol, NSCopying>\r\n    {\r\n        NSFNanoStore     *store;\r\n        NSString         *name;\r\n        NSString         *key;\r\n        BOOL             hasUnsavedChanges;\r\n    }\r\n\r\nAssume we have an object that represents a person and its root object is set to <i>self</i>, just as demonstrated above:\r\n\r\n    @interface Person : NSFNanoObject\r\n    {\r\n        NSString        *firstName;\r\n        NSString        *lastName;\r\n        NSString        *email;\r\n    }\r\n\r\nIf we wanted to retrieve all the existing people with <i>firstName</i> equal to <i>John</i> sorted by <i>lastName</i> we would do the following:\r\n\r\n    // Assume NanoStore has been opened elsewhere\r\n    NSFNanoStore *nanoStore = ...;\r\n\r\n    // Prepare the search\r\n    NSFNanoSearch *search = [NSFNanoSearch searchWithStore:nanoStore];\r\n    search.attribute = @\"firstName\";\r\n    search.match = NSFEqualTo;\r\n    search.value = @\"John\";\r\n     \r\n    // Prepare and set the sort descriptor\r\n    NSFNanoSortDescriptor *sortByLastName = [[NSFNanoSortDescriptor alloc]\r\n                                                initWithAttribute:@\"lastName\"\r\n                                                        ascending:YES];\r\n\r\n    search.sort = [NSArray arrayWithObject:sortByLastName];\r\n    \r\n    // Perform the search\r\n    NSArray *searchResults = [search searchObjectsWithReturnType:NSFReturnObjects\r\n                                                           error:nil];\r\n    \r\n    // Cleanup\r\n    [sortByLastName release];\r\n\r\n# Performance Tips\r\n\r\nNanoStore by defaults saves every object to disk one by one. To speed up inserts and edited objects, increase NSFNanoStore's `saveInterval` property.\r\n\r\n### Example\r\n\r\n    // Instantiate and open a NanoStore\r\n    NSFNanoStore *nanoStore = [NSFNanoStore\r\n        createAndOpenStoreWithType:NSFMemoryStoreType path:nil error:nil];\r\n    \r\n    // Increase the save interval\r\n    [nanoStore setSaveInterval:1000];\r\n    \r\n    // Do a bunch of inserts and/or edits\r\n    \r\n    // Don't forget that some objects could be lingering in memory. Force a save.\r\n    [nanoStore saveStoreAndReturnError:nil];\r\n\r\n### Note\r\n    If you set the saveInterval value to anything other one, keep in mind that some\r\n    objects may still be left unsaved after being added or modified. To make sure\r\n    they're saved properly, call:\r\n\t\r\n    - (BOOL)saveStoreAndReturnError:(out NSError **)outError\r\n\t\r\n    Choosing a good saveInterval value is more art than science. While testing\r\n    NanoStore using a medium-sized dictionary (iTunes MP3 dictionary) setting\r\n    saveInterval to 1000 resulted in the best performance. You may want to test with\r\n    different numbers and fine-tune it for your data set.\r\n\r\n### Warning\r\n    Setting saveInterval to a large number could result in decreased performance\r\n    because SQLite's would have to spend more time reading the journal file and\r\n    writing the changes to the store.\r\n\r\n# Need more help?\r\n\r\nThere are two quick ways to find answers: reading the documentation and browsing the Unit tests.\r\n\r\nWhile several attempts have been made to make the documentation easy to read and understand, it's far from perfect. If you find that the documentation is incomplete, incorrect or needs some clarification, please file a bug. I'll appreciate it and correct it as soon as possible:\r\n\r\n* NanoStore Documentation: http://dl.dropbox.com/u/2601212/NanoStore%202.0/html/index.html\r\n* NanoStore Bug Tracker: https://github.com/tciuro/NanoStore/issues\r\n* Twitter: http://twitter.com/nanostoredev\r\n\r\n# Official Source Repository\r\n\r\nThe official repository for NanoStore is hosted on GitHub: https://github.com/tciuro/NanoStore","tagline":"NanoStore is an open source, lightweight schema-less local key-value document store written in Objective-C for Mac OS X and iOS. ","google":"UA-30549712-1","note":"Don't delete this file! It's used internally to help with page regeneration."}